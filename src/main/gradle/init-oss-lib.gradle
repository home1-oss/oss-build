// see: https://docs.gradle.org/current/userguide/init_scripts.html
// see: http://blog.csdn.net/sbsujjbcy/article/details/52079413

void setRepositories(project, ext) {
  ext.settingsFileOpt = project.hasProperty('settings') ? project.getProperty('settings') : ""
  ext.securityFileOpt = project.hasProperty('settings.security') ? project.getProperty('settings.security') : ""
  if (ext.settingsFileOpt || ext.securityFileOpt) {
    ext.mavenSettings = new cn.home1.tools.maven.SettingsDecoder(ext.settingsFileOpt, ext.securityFileOpt, false)
  } else {
    ext.mavenSettings = new cn.home1.tools.maven.SettingsDecoder()
  }

  def envMavenOpts = System.getenv("MAVEN_OPTS")
  if (envMavenOpts) {
    def optionRepository = envMavenOpts.find("-D${ext.infrastructure}-nexus3\\.repository=([^\\s]+)")
    def repository = optionRepository ? optionRepository.replace("-D${ext.infrastructure}-nexus3.repository=", "") : null
    ext.nexusMirror = repository ? repository + '/maven-public/' : null
    ext.nexusRepository = repository ? repository : null
  } else if ('local' == "${ext.infrastructure}") {
    ext.nexusMirror = 'http://nexus3.local:28081/nexus/repository/maven-public/'
    ext.nexusRepository = 'http://nexus3.local:28081/nexus/repository'
  } else {
    ext.nexusMirror = null
    ext.nexusRepository = null
  }

  if ('github' == "${ext.infrastructure}") {
    ext.repositoryReleases = 'https://oss.sonatype.org/service/local/staging/deploy/maven2'
    ext.repositorySnapshots = 'https://oss.sonatype.org/content/repositories/snapshots/'
    ext.repositoryReleasesUser = ext.mavenSettings.getText("//server[id='OSSRH-releases']/username/text()")
    ext.repositoryReleasesPass = ext.mavenSettings.getText("//server[id='OSSRH-releases']/password/text()")
    ext.repositorySnapshotsUser = ext.mavenSettings.getText("//server[id='OSSRH-snapshots']/username/text()")
    ext.repositorySnapshotsPass = ext.mavenSettings.getText("//server[id='OSSRH-snapshots']/password/text()")
  } else {
    if (ext.nexusRepository?.trim()) {
      if ('local' == "${ext.infrastructure}") {
        ext.repositoryReleases = "${ext.nexusRepository}/maven-releases/"
        ext.repositorySnapshots = "${ext.nexusRepository}/maven-snapshots/"
      } else {
        ext.repositoryReleases = "${ext.nexusRepository}/maven-releases/"
        ext.repositorySnapshots = "${ext.nexusRepository}/maven-snapshots/"
      }
    } else {
      ext.repositoryReleases = null
      ext.repositorySnapshots = null
    }

    ext.repositoryReleasesUser = ext.mavenSettings.getText("//server[id='${ext.infrastructure}-nexus3-releases']/username/text()")
    ext.repositoryReleasesPass = ext.mavenSettings.getText("//server[id='${ext.infrastructure}-nexus3-releases']/password/text()")
    ext.repositorySnapshotsUser = ext.mavenSettings.getText("//server[id='${ext.infrastructure}-nexus3-snapshots']/username/text()")
    ext.repositorySnapshotsPass = ext.mavenSettings.getText("//server[id='${ext.infrastructure}-nexus3-snapshots']/password/text()")
  }
}

Closure pomConfig(gradle, project) {
//  def closure = new GroovyShell().evaluate(new File('submodule-pom.closure').getText('UTF-8'))
  def closure = Eval.me(new File('submodule-pom.closure').getText('UTF-8'))
  closure.project = project
  closure.gradle = gradle

  //println "closure"
  return closure
}

void pomXml(pom, gradle, project) {
  pom.withXml(pomConfig(gradle, project))
  if ( "${gradle.ext.springBootVersion}" ) {
    pom.artifactId = "${project.name}-spring-boot-${gradle.ext.springBootVersion}"
    pom.name = "${project.name}-spring-boot-${gradle.ext.springBootVersion}"
  } else {
    pom.artifactId = "${project.name}"
    pom.name = "${project.name}"
  }
  pom.version = "${project.version}"
}

initscript {
  repositories {
    jcenter()
    maven { url 'https://plugins.gradle.org/m2/' }
    //maven { url 'https://raw.github.com/chshawkn/maven-settings-decoder/mvn-repo/' }
  }
  dependencies {
    // Add dependency for build script, so we can access maven's settings.xml from our build script.
    classpath 'cn.home1.tools:maven-settings-decoder:1.0.5.OSS'
    classpath 'org.ajoberstar:grgit:1.7.0'
    // Add dependency for build script, so we can access Git from our build script.
  }
}

allprojects {
  // execute after settings.gradle
  //println "init.gradle allprojects ${project.name}"

  if (rootProject.name == project.name) {
    def dotGit = new File(".git")
    if (dotGit.exists() && dotGit.isDirectory()) {
      //ext.git = org.ajoberstar.grgit.Grgit.open(file('.')) // Open the Git repository in the current directory.
      ext.git = org.ajoberstar.grgit.Grgit.open(dir: '.')
      ext.branch = git.branch.current.name
      ext.revision = git.head().id // Get commit id of HEAD, Alternative is revision = git.head().abbreviatedId.
    } else {
      ext.branch = "unknown"
      ext.revision = "unknown"
    }

    rootProject.version = "${projectVersion}"
    //rootProject.version = "${projectVersion}.${git.head().abbreviatedId}"
    ext.version = rootProject.version

    if (project.hasProperty('infrastructure')) {
      ext.infrastructure = project.getProperty('infrastructure')
    } else if (System.getProperty("infrastructure")) {
      ext.infrastructure = System.getProperty("infrastructure")
    } else {
      ext.infrastructure = 'local'
    }

    setRepositories(project, ext)

    if (project.hasProperty('testFailureIgnore')) {
      ext.testFailureIgnore = project.getProperty('testFailureIgnore')
    } else if (System.getProperty("testFailureIgnore")) {
      ext.testFailureIgnore = System.getProperty("testFailureIgnore")
    } else {
      ext.testFailureIgnore = "false"
    }

    if ( gradle.ext.springBootApi && gradle.ext.springBootVersion ) {
      ext.springBootApi = gradle.ext.springBootApi
      ext.springBootVersion = gradle.ext.springBootVersion
    }

    ext.isReleaseVersion = !version.endsWith("SNAPSHOT")
    def secringGpg = new File("$rootDir/secring.gpg")
    ext.gpgKeyid = System.getenv("GPG_KEYID")
    ext.gpgPassphrase = System.getenv("GPG_PASSPHRASE")
    if (secringGpg.exists() && secringGpg.isFile() && ext.gpgKeyid && ext.gpgPassphrase) {
      ext.gpgEnabled = true
    } else {
      ext.gpgEnabled = false
    }
    if (ext.gpgEnabled) {
      ext."signing.keyId" = ext.gpgKeyid
      ext."signing.password" = ext.gpgPassphrase
      ext."signing.secretKeyRingFile" = "$rootDir/secring.gpg"
      if (rootProject == project) {
        println "apply signing on rootProject"
        apply plugin: 'signing'
      }
    }

    println ""
    println "--------------------------------------------------------------------------------"
    println "branch: " + ext.branch
    println "infrastructure: " + ext.infrastructure
    println "nexusMirror: " + ext.nexusMirror
    println "nexusRepository: " + ext.nexusRepository
    println "revision: " + ext.revision
    println "settingsFileOpt: " + ext.settingsFileOpt + ", securityFileOpt: " + ext.securityFileOpt
    println "repositoryReleases: " + ext.repositoryReleases
    println "repositorySnapshots: " + ext.repositorySnapshots
    if ("github" != "${ext.infrastructure}") {
      println "${ext.infrastructure}-nexus3-releases username: " + ext.mavenSettings.getText("//server[id='${ext.infrastructure}-nexus3-releases']/username/text()")
      println "${ext.infrastructure}-nexus3-snapshots username: " + ext.mavenSettings.getText("//server[id='${ext.infrastructure}-nexus3-snapshots']/username/text()")
    }
    println "gpgEnabled: " + ext.gpgEnabled
    println "isReleaseVersion: " + ext.isReleaseVersion
    if ( gradle.ext.springBootApi && gradle.ext.springBootVersion ) {
      println "springBootApi: " + ext.springBootApi
      println "springBootVersion: " + ext.springBootVersion
    }
    println "testFailureIgnore: " + ext.testFailureIgnore
    println "<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<"
  }

  repositories {
    mavenLocal()
    //maven { url 'file://' + new File(System.getProperty('user.home'), '.m2/repository').absolutePath
    if (nexusMirror?.trim()) {
      println "proxy repositories using: ${infrastructure} ${nexusMirror}"
      maven { url "${nexusMirror}" }
    }
    mavenCentral()
    maven { url 'http://repo.spring.io/libs-release' }
    maven { url 'http://repo.spring.io/libs-milestone' }
    maven { url 'http://repo.spring.io/libs-snapshot' }
    maven { url 'http://repo.spring.io/release' }
    maven { url 'http://repo.spring.io/milestone' }
    maven { url 'http://repo.spring.io/snapshot' }
    maven { url 'https://oss.sonatype.org/content/groups/public' }
    //maven { url 'https://oss.sonatype.org/content/repositories/snapshots' }
  }

//  apply plugin: 'maven'
//  configure(install.repositories.mavenInstaller) {
//    pom.project {
//      packaging 'jar'
//    }
//  }

  apply plugin: 'eclipse'
  eclipse {
    classpath {
      downloadSources = true
    }
  }

  apply plugin: 'idea'
  idea {
    module {// see .gitignore
      excludeDirs += [
        file('bin'),
        file('build'),
        file('logs'),
        file('data'),
        file('target'),
        file('node_modules')
      ]
      downloadSources = true

//      // Configuring Spring Loaded for use with Gradle and IntelliJ
//      inheritOutputDirs = false
//      outputDir = file("$buildDir/classes/main/")
//
//      iml {
//        beforeMerged { module ->
//          module.excludeFolders.clear()
//        }
//        whenMerged { module ->
//          module.excludeFolders.clear()
//        }
//      }
    }
  }

  subprojects {
    //println "init.gradle subprojects ${project.name}"

    project.version = rootProject.version

    apply plugin: 'java'
    if ( "${springBootVersion}" ) {
      archivesBaseName = "${project.name}-spring-boot-${springBootVersion}"
    }

    if (gpgEnabled) {
      apply plugin: 'signing'
      signing {
        required { isReleaseVersion && gradle.taskGraph.hasTask("uploadArchives") }
        sign configurations.archives
      }
    }

    // see: https://docs.gradle.org/current/userguide/maven_plugin.html
    apply plugin: 'maven'

    install {
      repositories.mavenInstaller {
        pomXml(pom, gradle, project)
      }
    }

    if (repositoryReleases?.trim() || repositorySnapshots?.trim()) {
      println "uploadArchives: true, gpgEnabled: ${gpgEnabled}"
      uploadArchives {
        repositories {
          mavenDeployer {
            if (gpgEnabled) {
              beforeDeployment { MavenDeployment deployment -> signing.signPom(deployment) }
            }

            // For *-SNAPSHOT versions the snapshotRepository is used. Otherwise the releases repo is used.
            repository(url: "${repositoryReleases}") {
              authentication(userName: "${repositoryReleasesUser}", password: "${repositoryReleasesPass}")
            }
            snapshotRepository(url: "${repositorySnapshots}") {
              authentication(userName: "${repositorySnapshotsUser}", password: "${repositorySnapshotsPass}")
            }
            pomXml(pom, gradle, project)
          }
        }
      }
    } else {
      println "uploadArchives: false, gpgEnabled: ${gpgEnabled}"
    }

    sourceSets {
      main {
        java {
          srcDirs = ['src/main/java']
          if ( "${springBootVersion}" ) {
            srcDir "src/main/java-spring-boot-${springBootVersion}"
          }
        }
        resources {
          srcDirs = ['src/main/resources']
          includes = ["**/*"]
        }
      }
      test {
        java {
          srcDirs = ['src/test/java']
          if ( "${springBootVersion}" ) {
            srcDir "src/test/java-spring-boot-${springBootVersion}"
          }
        }
        resources {
          srcDirs = ['src/test/resources']
        }
      }
    }

    //jar {
      // use artifactId instead of classifier
      //classifier = "spring-boot-${springBootVersion}"
    //}

    javadoc {
      failOnError = false
    }
    task sourcesJar(type: Jar, dependsOn: classes) {
      classifier = 'sources'
      from sourceSets.main.allSource
    }
    task javadocJar(type: Jar, dependsOn: javadoc) {
      classifier = 'javadoc'
      from javadoc.destinationDir
    }
    artifacts {
      archives sourcesJar
      archives(javadocJar) {
        type = 'javadoc'
      }
    }

    compileJava {
      sourceCompatibility = JavaVersion.VERSION_1_8
      targetCompatibility = JavaVersion.VERSION_1_8
      options.compilerArgs << '-Xlint:unchecked' << '-Xlint:deprecation' << '-parameters'
    }
    compileJava.options.encoding = 'UTF-8'
    compileJava.dependsOn(processResources)
    compileTestJava.options.encoding = 'UTF-8'
    compileTestJava.options.compilerArgs << '-Xlint:unchecked' << '-Xlint:deprecation' << '-parameters'

    if ( "${jacocoVersion}" ) {
      apply plugin: 'jacoco'
      jacoco {
        toolVersion = "${jacocoVersion}"
        //reportsDir = file("$buildDir/reports/jacoco")
      }
      jacocoTestReport {
        reports {
          xml.enabled false
          csv.enabled false
          //html.destination "${buildDir}/jacocoHtml"
        }
      }
    }

    test {
      // see: https://www.mkyong.com/gradle/gradle-how-to-continue-build-if-test-is-failed/
      ignoreFailures = "${testFailureIgnore}".toBoolean()
      if ( "${jacocoVersion}" ) {
        jacoco {
          // @FeignClient problem. Method $jacocoInit not annotated with HTTP method type
          excludes = ["cn.home1.commons.*Client"]
        }
      }
      // show standard out and standard error of the test JVM(s) on the console, without this
      // the text output printed by the tests won't show.
      // ref: https://docs.gradle.org/current/dsl/org.gradle.api.tasks.testing.Test.html
      testLogging.showStandardStreams = false
      def testCount = 0
      afterTest { descriptor, result ->
        // descriptor is of type TestDescriptor, result is of type TestResult
        // ref: https://docs.gradle.org/current/javadoc/org/gradle/api/tasks/testing/TestDescriptor.html
        // ref: https://docs.gradle.org/current/javadoc/org/gradle/api/tasks/testing/TestResult.html
        logger.lifecycle("Test {count: ${++testCount} name: $descriptor result: $result.resultType}")
      }
      useJUnit {
        exclude '**/*IT.class'
      }
    }

    task integrationTest(type: Test) {
      ignoreFailures = "${testFailureIgnore}".toBoolean()
      testLogging.showStandardStreams = false
      def testCount = 0
      afterTest { descriptor, result ->
        logger.lifecycle("IntegrationTest {count: ${++testCount} name: $descriptor.name result: $result.resultType}")
      }
      useJUnit {
        include '**/*IT.class'
      }
    }
    //check.dependsOn -= integrationTest
  }

  //task version << {
  task version {
    doLast {
      logging.captureStandardOutput LogLevel.QUIET
      logging.captureStandardError LogLevel.ERROR
      logger.quiet("name:" + project.name)
      logger.quiet("version:" + project.version)
      logger.quiet("revision:" + revision)
      if ( "${springBootVersion}" && "${springBootApi}" ) {
        logger.quiet("spring-boot_version:" + springBootVersion)
        logger.quiet("spring-boot_api:" + springBootApi)
      }
      logging.captureStandardOutput LogLevel.INFO
    }
  }

  if (rootProject.name == project.name && "${gradleVersion}" ) {
    task wrapper(type: Wrapper) { gradleVersion = "${gradleVersion}" }
  }
}
